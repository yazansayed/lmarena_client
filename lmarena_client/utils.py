from __future__ import annotations

import secrets
import time
import traceback
from typing import Any, Optional


def uuid7() -> str:
    """
    Generate a UUIDv7 using Unix epoch milliseconds.
    Matches the provider behavior from g4f extraction.
    """
    timestamp_ms = int(time.time() * 1000)
    rand_a = secrets.randbits(12)
    rand_b = secrets.randbits(62)

    uuid_int = timestamp_ms << 80
    uuid_int |= (0x7000 | rand_a) << 64
    uuid_int |= (0x8000000000000000 | rand_b)

    hex_str = f"{uuid_int:032x}"
    return f"{hex_str[0:8]}-{hex_str[8:12]}-{hex_str[12:16]}-{hex_str[16:20]}-{hex_str[20:32]}"


def log(*args: Any) -> None:
    # minimal logging hook; can be swapped later
    try:
        print(*args, flush=True)
    except Exception:
        pass


def log_exc(context: str, exc: BaseException) -> None:
    log(f"[lmarena-client] ERROR in {context}: {type(exc).__name__}: {exc}")
    try:
        log(traceback.format_exc())
    except Exception:
        pass


def is_cloudflare_html(text: str) -> bool:
    if not text:
        return False
    if "Generated by cloudfront" in text or '<p id="cf-spinner-please-wait">' in text:
        return True
    if "<title>Attention Required! | Cloudflare</title>" in text or 'id="cf-cloudflare-status"' in text:
        return True
    if "<title>Just a moment...</title>" in text:
        return True
    return '<div id="cf-please-wait">' in text


def looks_like_recaptcha_failure(text: str) -> bool:
    return "recaptcha validation failed" in (text or "").lower()


async def read_response_text_safe(response, limit_kb: int = 64) -> str:
    try:
        text = await response.text()
    except Exception as e:
        return f"<failed to read response text: {type(e).__name__}: {e}>"

    if text is None:
        return ""

    limit = limit_kb * 1024
    if len(text) > limit:
        return text[:limit] + f"\n\n<truncated: {len(text) - limit} bytes omitted>"
    return text
